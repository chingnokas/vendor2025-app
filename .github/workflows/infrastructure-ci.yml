name: ğŸ—ï¸ Infrastructure CI/CD with OpenTofu

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'infrastructure/**'
      - 'helm/**'
      - 'monitoring/**'
      - '.github/workflows/infrastructure-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'infrastructure/**'
      - 'helm/**'
      - 'monitoring/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: "1.6.0"
  TOFU_VERSION: "1.6.0"

jobs:
  detect-changes:
    name: ğŸ” Detect Infrastructure Changes
    runs-on: ubuntu-latest
    outputs:
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
      monitoring-changed: ${{ steps.changes.outputs.monitoring }}
      helm-changed: ${{ steps.changes.outputs.helm }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infrastructure:
              - 'infrastructure/**'
            monitoring:
              - 'monitoring/**'
            helm:
              - 'helm/**'

      - name: ğŸŒ Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

  validate-infrastructure:
    name: ğŸ” Validate OpenTofu Configuration
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.infrastructure-changed == 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: ğŸ” Format check
        working-directory: ./infrastructure
        run: tofu fmt -check -recursive

      - name: ğŸ”§ Initialize OpenTofu
        working-directory: ./infrastructure
        run: tofu init
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: âœ… Validate configuration
        working-directory: ./infrastructure
        run: tofu validate

      - name: ğŸ”’ Security scan with tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ./infrastructure
          soft_fail: true

  plan-infrastructure:
    name: ğŸ“‹ Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [detect-changes, validate-infrastructure]
    if: needs.detect-changes.outputs.infrastructure-changed == 'true' || github.event_name == 'workflow_dispatch'
    
    environment:
      name: ${{ needs.detect-changes.outputs.environment }}
      url: https://cloud.digitalocean.com/kubernetes/clusters
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: ğŸ”§ Initialize OpenTofu
        working-directory: ./infrastructure
        run: tofu init
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ“‹ Plan infrastructure changes
        working-directory: ./infrastructure
        run: |
          tofu plan \
            -var-file="environments/${{ needs.detect-changes.outputs.environment }}.tfvars" \
            -var="do_token=${{ secrets.DIGITALOCEAN_TOKEN }}" \
            -out=tfplan-${{ needs.detect-changes.outputs.environment }}
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ“¤ Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ needs.detect-changes.outputs.environment }}
          path: infrastructure/tfplan-${{ needs.detect-changes.outputs.environment }}
          retention-days: 5

      - name: ğŸ’¬ Comment plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Get plan output
            const planOutput = execSync('cd infrastructure && tofu show -no-color tfplan-${{ needs.detect-changes.outputs.environment }}', { encoding: 'utf8' });
            
            const comment = `## ğŸ—ï¸ Infrastructure Plan - ${{ needs.detect-changes.outputs.environment }}
            
            <details>
            <summary>ğŸ“‹ OpenTofu Plan Output</summary>
            
            \`\`\`
            ${planOutput}
            \`\`\`
            </details>
            
            **Environment:** ${{ needs.detect-changes.outputs.environment }}
            **Action:** Plan completed successfully
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  apply-infrastructure:
    name: ğŸš€ Apply Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [detect-changes, plan-infrastructure]
    if: |
      (needs.detect-changes.outputs.infrastructure-changed == 'true' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    
    environment:
      name: ${{ needs.detect-changes.outputs.environment }}
      url: https://cloud.digitalocean.com/kubernetes/clusters
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: ğŸ“¥ Download plan artifact
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ needs.detect-changes.outputs.environment }}
          path: infrastructure/

      - name: ğŸ”§ Initialize OpenTofu
        working-directory: ./infrastructure
        run: tofu init
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸš€ Apply infrastructure changes
        working-directory: ./infrastructure
        run: tofu apply -auto-approve tfplan-${{ needs.detect-changes.outputs.environment }}
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ“¤ Export cluster configuration
        working-directory: ./infrastructure
        run: |
          # Get cluster info
          CLUSTER_ID=$(tofu output -raw cluster_id)
          CLUSTER_NAME=$(tofu output -raw cluster_name)
          
          # Save cluster info
          echo "CLUSTER_ID=$CLUSTER_ID" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          
          # Export kubeconfig
          curl -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.DIGITALOCEAN_TOKEN }}" \
            "https://api.digitalocean.com/v2/kubernetes/clusters/$CLUSTER_ID/kubeconfig" \
            | jq -r '.kubeconfig' | base64 -d > kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ“¤ Upload kubeconfig artifact
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig-${{ needs.detect-changes.outputs.environment }}
          path: infrastructure/kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml
          retention-days: 1

      - name: â³ Wait for cluster to be ready
        run: |
          echo "â³ Waiting for cluster to be fully ready..."
          sleep 60
          
          # Test cluster connectivity
          kubectl --kubeconfig=infrastructure/kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml cluster-info
          kubectl --kubeconfig=infrastructure/kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml get nodes

  deploy-monitoring:
    name: ğŸ“Š Deploy Monitoring Stack
    runs-on: ubuntu-latest
    needs: [detect-changes, apply-infrastructure]
    if: |
      always() && 
      (needs.apply-infrastructure.result == 'success' || 
       (needs.detect-changes.outputs.monitoring-changed == 'true' && github.ref == 'refs/heads/main'))
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.detect-changes.outputs.environment }}
          path: ./

      - name: ğŸ”§ Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.14.0'

      - name: ğŸ“Š Add monitoring Helm repositories
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update

      - name: ğŸ—ï¸ Create monitoring namespace
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            create namespace monitoring --dry-run=client -o yaml | \
            kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml apply -f -

      - name: ğŸ“Š Deploy Prometheus and Grafana
        run: |
          helm --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            upgrade --install monitoring-stack prometheus-community/kube-prometheus-stack \
            --namespace monitoring \
            --values helm/monitoring-stack/values.yaml \
            --set grafana.adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123' }} \
            --wait --timeout=10m

      - name: ğŸ” Verify monitoring deployment
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            get pods -n monitoring
          
          echo "ğŸ“Š Monitoring stack deployed successfully!"
          echo "ğŸ”— Grafana will be available via LoadBalancer IP"

  deploy-argocd:
    name: ğŸ”„ Deploy ArgoCD
    runs-on: ubuntu-latest
    needs: [detect-changes, apply-infrastructure, deploy-monitoring]
    if: always() && needs.apply-infrastructure.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.detect-changes.outputs.environment }}
          path: ./

      - name: ğŸ”§ Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.14.0'

      - name: ğŸ”„ Add ArgoCD Helm repository
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update

      - name: ğŸ—ï¸ Create ArgoCD namespace
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            create namespace argocd --dry-run=client -o yaml | \
            kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml apply -f -

      - name: ğŸ”„ Deploy ArgoCD
        run: |
          helm --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            upgrade --install argocd argo/argo-cd \
            --namespace argocd \
            --set server.service.type=LoadBalancer \
            --set server.service.annotations."service\.beta\.kubernetes\.io/do-loadbalancer-name"="argocd-server" \
            --set server.service.annotations."service\.beta\.kubernetes\.io/do-loadbalancer-size-slug"="lb-small" \
            --wait --timeout=10m

      - name: ğŸ”„ Configure ArgoCD project and application
        run: |
          # Wait for ArgoCD to be ready
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          
          # Apply ArgoCD project and application
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            apply -f argocd/project.yaml
          
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            apply -f argocd/application.yaml

      - name: ğŸ” Get ArgoCD access information
        run: |
          echo "ğŸ”„ ArgoCD deployed successfully!"
          echo ""
          echo "ğŸ“‹ Access Information:"
          echo "ğŸ”— ArgoCD UI will be available via LoadBalancer IP"
          echo "ğŸ‘¤ Username: admin"
          echo "ğŸ”‘ Password: Get with this command:"
          echo "kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"

  deploy-applications:
    name: ğŸš€ Deploy Applications with Helm
    runs-on: ubuntu-latest
    needs: [detect-changes, apply-infrastructure, deploy-monitoring, deploy-argocd]
    if: always() && needs.apply-infrastructure.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.detect-changes.outputs.environment }}
          path: ./

      - name: ğŸ”§ Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.14.0'

      - name: ğŸ—ï¸ Create application namespace
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            create namespace auth-app --dry-run=client -o yaml | \
            kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml apply -f -

      - name: ğŸ” Create image pull secret
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            create secret docker-registry ghcr-secret \
            --namespace=auth-app \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --dry-run=client -o yaml | \
            kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml apply -f -

      - name: ğŸš€ Deploy auth-stack application
        run: |
          helm --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            upgrade --install auth-stack ./helm/auth-stack \
            --namespace auth-app \
            --values helm/auth-stack/values-${{ needs.detect-changes.outputs.environment }}.yaml \
            --set global.environment=${{ needs.detect-changes.outputs.environment }} \
            --wait --timeout=10m

      - name: ğŸ” Verify application deployment
        run: |
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            get pods -n auth-app
          
          kubectl --kubeconfig=kubeconfig-${{ needs.detect-changes.outputs.environment }}.yaml \
            get services -n auth-app
          
          echo "ğŸš€ Applications deployed successfully!"

  deployment-summary:
    name: ğŸ“‹ Deployment Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, apply-infrastructure, deploy-monitoring, deploy-argocd, deploy-applications]
    if: always()
    
    steps:
      - name: ğŸ“‹ Generate deployment summary
        run: |
          echo "## ğŸ—ï¸ Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.detect-changes.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** auth-stack-${{ needs.detect-changes.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ“Š Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.apply-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Monitoring | ${{ needs.deploy-monitoring.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD | ${{ needs.deploy-argocd.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Applications | ${{ needs.deploy-applications.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ”— Access Information" >> $GITHUB_STEP_SUMMARY
          echo "- **DigitalOcean Console:** [Kubernetes Clusters](https://cloud.digitalocean.com/kubernetes/clusters)" >> $GITHUB_STEP_SUMMARY
          echo "- **Grafana:** Available via LoadBalancer IP (monitoring namespace)" >> $GITHUB_STEP_SUMMARY
          echo "- **ArgoCD:** Available via LoadBalancer IP (argocd namespace)" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** Available via LoadBalancer IP (auth-app namespace)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ”§ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Get LoadBalancer IPs: \`kubectl get services --all-namespaces\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Access Grafana with admin credentials" >> $GITHUB_STEP_SUMMARY
          echo "3. Access ArgoCD and sync applications" >> $GITHUB_STEP_SUMMARY
          echo "4. Monitor application health in dashboards" >> $GITHUB_STEP_SUMMARY

  destroy-infrastructure:
    name: ğŸ—‘ï¸ Destroy Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    
    environment:
      name: ${{ needs.detect-changes.outputs.environment }}
      url: https://cloud.digitalocean.com/kubernetes/clusters
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: ğŸ”§ Initialize OpenTofu
        working-directory: ./infrastructure
        run: tofu init
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ—‘ï¸ Destroy infrastructure
        working-directory: ./infrastructure
        run: |
          tofu destroy \
            -var-file="environments/${{ needs.detect-changes.outputs.environment }}.tfvars" \
            -var="do_token=${{ secrets.DIGITALOCEAN_TOKEN }}" \
            -auto-approve
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: ğŸ“‹ Destruction summary
        run: |
          echo "ğŸ—‘ï¸ Infrastructure destroyed successfully!"
          echo "Environment: ${{ needs.detect-changes.outputs.environment }}"